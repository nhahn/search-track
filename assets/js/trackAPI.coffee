###!!!
#! This file is autogenerated. To modify please change the appropriate file in
#! the js/api folder
###


###
#
# Superclass for all of our object classes. This has some default methods we can use for organization
#
###

class Base

  constructor: (paramsList, params) ->
    #Default properties for our object
    filtered = _.pick(params, _.keys(paramsList))
    _.extendOwn(paramsList, filtered)
      
    for own param, val of paramsList
      throw new TypeError("Missing required property #{param}") if val == undefined
      this[param] = val

  table: () ->
    db[this.constructor.name]
  @table: () ->
    db[this.name]
  
  ## TODO if i really want this -- could be stupidly complicated :/
  associationHash: () ->
    for own prop, val of this
      if _.isObject(val) and val instanceof Base #Check this is a populated value we want to deconstruct
       {prop: prop, obj: val, table: this.table()}
       
  save: () ->
    this.table().put(this).then (id) =>
      @id = id
      return this
     
  fillAssociation: (name) ->
   this.table().get(this[name.capitalize()]).then (obj) =>
      this[name] = obj
    .catch (err) =>
      Error.warn(err)
      
  @fillAssociations: (objs, name) ->
    Promise.map(objs, (obj) -> obj.fillAssociation(name))
    
  capitalize = (s) ->
    s.charAt(0).toUpperCase() + s.substring(1).toLowerCase()
  
  @find: (id) ->
    return this.table().get(id).then (obj) ->
      return obj
  
  delete: () ->
    this.table().delete(@id)
###
#
# Table for tracking individual web pages we want to monitor in searches / tasks. 
#
###

# TODO define some of these parameters?

class Page extends Base
  constructor: (params) ->
    super {
      favicon: ''
      isSearch: false
      blacklisted: false
      query: ''
      url: undefined
      domain: ''
      fragmentless: ''
      time: Date.now()
      title: ''
      vector: {}
      topics: ''
      topic_vector: []
      size: 0
      notes: ''
      color: 'rgba(219,217,219,1)'
      depth: 0
      height: 0 # for the drag-and-drop list (could be adapted for 2D manipulation)
      favorite: false   # will be able to "favorite" tabs
    }, params

  @generatePage: (url) ->
    uri = new URI(url)
    fragment = uri.fragment()
    uri.fragment("")
    query = ''
    #Check if it is a Google search
    matches = url.match(/www\.google\.com\/.*q=(.*?)($|&)/)
    if matches != null
      query = decodeURIComponent(matches[1].replace(/\+/g, ' '))
    
    page = new Page({url: url, domain: uri.domain(), fragmentless: uri.toString(), query: query, isSearch: if query != "" then true else false})
    page.save()

###
#
# Table for tracking page level events. We associated this with a pageVisit -- b/c someone could be using a page differently # between different visits 
#
###

class PageEvent extends Base
  constructor: (params) ->
    super {
      type: 'scrollPostion' # Enum of ['scrollPosition']
      pageVisit: undefined # The particular visit to a page we are recording events for 
      data: '' #Field depends on the above type
      time: Date.now()
    }, params
###
#
# Table individual web-page visits. This is created whenever someone visits a page by navigating to its URL
# (think of it as a history event).
#
###

class PageVisit extends Base
  constructor: (params) ->
    super {
      page: undefined # The page visited
      tab: undefined # The tab this page was visited from
      task: '' #The "task" this particular visit was associated with. A page could be associated with different tasks!!
      referrer: '' #If a another page "referred" us here, we record the previous pageEvent that did so (so we keep track of tasks)
      type: '' #Enum of navigation ['forward', 'back', 'link', 'typed', 'navigation']
      time: Date.now() #When this visit occured
    }, params
    
  @forPage: (pageId) ->
    db.PageVisit.where('page').equals(pageId)
  
  @forTab: (tabId) ->
    db.PageVisit.where('tab').equals(tabId)
    
  # Returns the path of PageVisits required to get to this point
  getPath: () ->
    if @referrer
      db.PageVisit.get(@referrer).then (visit) ->
        return [visit, visit.getPath()]
      .spread (visit,arr) ->
        return [visit].concat(arr)
    else
      return this
    
# Sidenote: for a possible graph in order to visualize these @see: https://github.com/cpettitt/dagre-d3/wiki
###
#
# Table for tracking searches we've performed
#
###

class Search extends Base
  constructor: (params) ->
    properties = _.extend({
      name: ''
      tabs: []
      date: Date.now()
      visits: 1
    }, params)
    @name = properties.name
    @tabs = properties.tabs
    @date = properties.date
    @visits = properties.visits

###
#
# Global Application settings hash (that auto-updates in the backend and refreshes stuff elsewhere)
#
# AppSettings.on (setting..., func()) : 
#   * Takes and array of settings, and a function. Will call the function when the setting is updated.
#   * Note the special "setting", 'ready', that will be called when it has finished fetching the settings
#   from chrome storage. 
#
# AppSettings.listSettings :
#   * Returns an array of all of the different setting types 
#
# To add a new setting -- create a new entry in the 'settings' array, and then it will become available for use
###
Logger.useDefaults()

window.AppSettings = (() ->
  obj = {}
  settings = ['trackTab', 'trackPage', 'hashTracking', 'logLevel'] #Add a setting name here to make it available for use
  handlers = {}
  get_val = _.map settings, (itm) ->
    return 'setting-'+itm
    
  chrome.storage.local.get get_val, (items) ->
    for own key, val of items
      obj[key] = val
    for handler in handlers.ready
      handler.call(obj)
    
  
  for setting in settings
    ((setting) ->
      Object.defineProperty obj, setting, {
        set: (value) ->
          hsh = {}
          hsh['setting-'+setting] = value
          obj['setting-'+setting] = value
          chrome.storage.local.set hsh, () ->
            if handlers[setting]
              for handler in handlers[setting]
                handler.call()
            
        get: () ->
          return obj['setting-'+setting]
      }
    )(setting)

  obj.on = (types..., func) ->
    for type in types
      console.log ("Invalid Event!") if settings.indexOf(type) < 0 && ['ready'].indexOf(type) < 0
      if handlers[type]
        handlers[type].push(func)
      else
        handlers[type] = [func]
  
  obj.listSettings = () ->
    return settings
     
  chrome.storage.onChanged.addListener (changes, areaName) ->
    for own key, val of changes
      if obj.hasOwnProperty(key)
        obj[key] = val.newValue
    
  return obj
)()

AppSettings.on 'logLevel', 'ready', (settings) ->
  Logger.setLevel(AppSettings.logLevel)
#####
#
# Table for tab-based page tracking. Helps organizing searches and history
#
#####

class Tab extends Base
  constructor: (params) ->
    super {
      tab: undefined
      windowId: -1
      openerTab: -1
      position: 0
      session: '' #the 
      pageVisit: '' #The pageVisit that is currently active
      status: 'active' # This is an enum: ['active', 'stored', 'closed', 'temp']
      task: '' #The ID of the task this tab is associated with (TODO blank is newTab page i guess??)
      date: Date.now()
    }, params
    
  store: () ->
    chrome.tabs.removeAsync(@tab).then () =>
      chrome.session.getRecentlyClosedAsync({maxResults: 1})
    .then (sessions) =>
      @session = sessions[0]
      this.save()
      
  @findByTabId: (tabId) ->
    db.Tab.where('tab').equals(tabId).and((val) -> val.status is 'active').first()
   
  
  
    
    
###
#
# Table for tracking individual tab events 
#
###

class TabEvent extends Base
  constructor: (params) ->
    super {
      type: 'updated' # Enum of ['windowFocus', 'tabFocus', 'moved', 'removed', 'attached', 'updated']
      tab: undefined # Tab this is associated with
      from: '' #Field depends on the above type
      to: '' #Field depends on the above type
      time: Date.now()
    }, params

class Task extends Base
  #jQuery-esque constructor (you only speciy the parameters in a hash that you don't want to be default / are required
  constructor: (params) ->
    super {
      name: undefined                  #Task name (required)
      dateCreated: Date.now()   #Date task was created
      order: 999                #Order of the task?
      isTemp: false             #Are we using a temporary name? try and fill it in if we are
      hidden: false             #Whether the task is visible or not to the user TODO get rid of me??
      isSearch: false           #Whether the task spawned from a search or not
      parent: ''                #The parent task for this task
      level: 1                  #The nested "level" of the task (1 being the child of the tree)
      annotation: "Annotate Here. (Tip: Use Command+Period to minimize)"
    }, params 

  # Doesn't work
  changeName: (name) ->
    console.log name
    console.log @name
    console.log this
    console.log this.table()
    @name = name
    return db.Task.put(this).then (id) =>
      return this

  #TODO have more complex heuristics, etc for getting an existing task
  ###
  # Generate or reuse a task based on the page, tab, etc.
  # param tab - a Tab object that we want to find / or create a task for
  # param page - the Page object we want to find / or create a task for
  # param foce - Forcible generate a new task for the page and tab
  ###
  @generateBaseTask: (tab, page, force) ->
    throw new ReferenceError("Tab is not defined for creating a new task #{tab}") if !tab 
    if page and page.isSearch
      return Dexie.Promise.all([db.Task.where('name').equals(page.query).first(), db.Task.get(tab.task)]).then (args) ->
        [searchTask, curTask] = args
        return searchTask if searchTask #We've done this search before -- keep it under the same parent task before
        task = new Task({name: page.query, hidden: false, isSearch: true, parent: curTask.parent}) #We haven't done this before -- assign it to our current parent
        return task.save()
    else if force or !tab.task
      #Try and find a previous PageVisit (ignore the one already added!)
      return Dexie.Promise.all([
        db.PageVisit.where('page').equals(page.id).and((val) -> val.id != tab.pageVisit).mostRecent()
        db.Task.get(tab.task)
      ]).then (args) ->
        [pageVisit, curTask] = args
        if pageVisit and pageVisit.task
          return Task.find(pageVisit.task) #We will, by default, try and use the most recent task for this page (child and parent)
        else
          if tab.task
            return db.Task.get(tab.task).then (task) ->
              Task.generateNewTabTemp(curTask.parent)
          else
            return Task.generateParentTemp().then (par) ->
              Task.generateNewTabTemp(par.id)
    else
      return Task.find(tab.task)
      
  ###
  # Generate a temporary low level task for the given parent that will be filled in later
  # param parent - The parent task we want to generate a base task for
  ###
  @generateNewTabTemp: (parent) ->
    task = new Task({name: "Temp"+Math.floor(Math.random()*10000), parent: parent, level: 1, isTemp: true})
    task.save()
    
  ###
  # Generate a temporary parent when a new window is created
  ###
  @generateParentTemp: () ->
    task = new Task({name: "Temp"+Math.floor(Math.random()*10000), level: 2, isTemp: true})
    task.save()
    
  removeTempTask: (replacedTask) ->
    self = this
    if @isTemp and @parent and @parent != replacedTask.parent
      return @delete().then () ->
        db.Task.get(self.parent)
      .then (parent) ->
        if parent and parent.isTemp 
          parent.removeTempTask()
    else
      return @delete()
      
  #Renames temporary base tasks, and collapses those tasks that
  #have the same titles into each other (within the same detected task)
  nameTempTask: (page) ->
    return this if !@isTemp
    return this if page.url.match(/^chrome/) or page.url.match(/https:\/\/google.com/)
    self = this
    db.transaction 'rw!', db.Task, db.Tab, db.PageVisit, () ->
      #Loopup other tasks that might have the same name
      Dexie.Promise.all([
        db.Task.where('name').equals(page.title).toArray()
        db.Task.get(self.parent)
      ]).then (args) ->
        [res, parent] = args
        if res.length > 0
          #Find one with a matching parent
          match = _.find(res, (val) -> val.parent == self.parent)
          if !match and parent.isTemp #In this case -- we want to find any other ones with temp parents as well (and collapse them)
            match = db.Task.where('id').anyOf(_.map(res, (val) -> val.parent)).and((val) -> val.isTemp).first()
          return Dexie.Promise.all([match, parent])
        else
          throw new RecordMissingError("No existing task with that name")
      .then (args) ->
        [existingTask, parent] = args
        throw new RecordMissingError("No existing task with a shared temporary parent") if !existingTask
        db.Tab.where('task').equals(self.id).toArray().then (res) ->
          for tab in res
            tab.task = existingTask.id
            db.Tab.update(tab.id, {task: existingTask.id})
        db.PageVisit.where('task').equals(self.id).toArray().then (res) ->
          for pageVisit in res
            pageVisit.task = existingTask.id
            db.PageVisit.update(pageVisit.id, {task: existingTask.id})
        self.delete()
        parent.delete() if parent.isTemp
        return existingTask
      .catch RecordMissingError, (err) ->
        Logger.debug(err)
        self.name = page.title
        self.isTemp = false
        self.save()
  

  cleanUp: () ->
    chrome.windows.getCurrentAsync({populate: true}).then (window) =>
      # Record the position of each tab in the window
      ids = _.map window.tabs, (t) -> t.id
      db.Tab.where('tabId').anyOf(ids).and((val) -> val.status is 'active')
    .then(tabs) =>
      Promise.map tabs, (tab) =>
        if @tabs.indexOf(tab.id) >= 0
          return tab
          #keep the tab in the window
        else
          return tab.store()
      
  getChildren: () ->
    db.Task.where('parent').equals(@id)
    
  @getTopLevelTasks: () ->
    db.Task.where('parent').equals('')

#####
#
# Theses are shortcut scopes for managing tables
#
####

(->
  ScopeAddons = (db) ->
  
    #Will get the most recent record for a given collection
    db.Collection.prototype.mostRecent = () ->
      return this.reverse().sortBy('time').then (coll) ->
        return coll[0]
        
    db.Collection.prototype.previousOne = () ->
      return this.reverse().sortBy('time').then (coll) ->
        return coll[1]
  
  Dexie.addons.push(ScopeAddons)
)()
###
#
# Sets-up our DB tables (using Dexie.js). There are 5 different tables, specified below (along with their definitions). 
# For each table, there is an additional section that describes an object it maps to. 
#
###
   
###
#
# Optional (not currently used) methods to persist DB info to file
#
###
dbMethods = (() -> 
  obj = {}
  obj.generateUUID = ->
    d = (new Date).getTime()
    uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) ->
      r = (d + Math.random() * 16) % 16 | 0
      d = Math.floor(d / 16)
      (if c == 'x' then r else r & 0x3 | 0x8).toString 16
    )
    uuid

  objects2csv = (objects, attributes) ->
    csvData = new Array()
    csvData.push '"' + attributes.join('","') + '"'
    for object in objects
      row = []
      for attribute in attributes
        row.push ("" + object[attribute]).replace(/\\/g, "\\\\").replace(/"/g, '\\"') #'
      csvData.push '"' + row.join('","') + '"'
    return csvData.join('\n') + '\n'


  persistToFile = (filename, csv) ->
    onInitFs = (fs) ->
      fs.root.getFile(filename, {create:true}, (fileEntry) ->
        fileEntry.createWriter( (writer) ->
          blob = new Blob([csv], {type: 'text/csv'});
          writer.seek(writer.length)
          writer.write(blob)
        , errorHandler)
      , errorHandler)
    window.webkitRequestFileSystem(window.PERSISTENT, 50*1024*1024, onInitFs, errorHandler);
  
  errorHandler = (e) ->
    msg = ''

    switch (e.code)
      when FileError.QUOTA_EXCEEDED_ERR
        msg = 'QUOTA_EXCEEDED_ERR'
      when FileError.NOT_FOUND_ERR
        msg = 'NOT_FOUND_ERR'
      when FileError.SECURITY_ERR
        msg = 'SECURITY_ERR'
      when FileError.INVALID_MODIFICATION_ERR
        msg = 'INVALID_MODIFICATION_ERR'
      when FileError.INVALID_STATE_ERR
        msg = 'INVALID_STATE_ERR'
      else
        msg = 'Unknown Error'

    console.log('Error: ' + msg)
  return obj
)()

###
#
# Database that keeps track of the searches we have performed with Google
#
#
###

db_changes = chrome.runtime.connect {name: 'db_changes'}
window.db = new Dexie('searchTrack')
db.version(1).stores({
  Search: '$$id,&name,*tabs,task' #Searches from Google we are tracking
  Task: '$$id,name,dateCreated,parent' #table of tasks
  Page: '$$id,url' #Pages we are keeping info on
  PageVisit: '$$id,tab,task,page,referrer' #Visits to individual pages
  PageEvent: '$$id,pageVisit,type,time' #Events for a specific visit to a page
  Tab: '$$id,tab,task' # Tabs we are watching
  TabEvent: '$$id,tab,type,time' #Tab-specific events
  # SavedInfo: '$$id,importance,time' # database for information that user marks as "for later"
})

db.Page.mapToClass(window.Page)
db.Search.mapToClass(window.Search)
db.Task.mapToClass(window.Task)
db.Tab.mapToClass(window.Tab)
db.TabEvent.mapToClass(window.TabEvent)
db.PageEvent.mapToClass(window.PageEvent)
db.PageVisit.mapToClass(window.PageVisit)

db.open()
  
###
#
# Promisify stuff from chrome API
#
###

promisifyChrome = (api) ->
  _.each _.functions(api), (func) ->
    api[func+"Async"] = (params...) ->
      return new Promise (resolve, reject) ->
        cb = (res...) ->
          reject(new ChromeError(chrome.runtime.lastError.message)) if chrome.runtime.lastError
          resolve(res...)
        params.push(cb)
        api[func].apply(null, params)


promisifyChrome(chrome.windows)
promisifyChrome(chrome.tabs)
promisifyChrome(chrome.sessions)
promisifyChrome(chrome.history)

class RecordMissingError extends Error
  constructor: (@message) ->
    @name = 'RecordMissingError'
    Error.captureStackTrace(this, RecordMissingError)

class ChromeError extends Error
  constructor: (@message) ->
    @name = 'ChromeError'
    Error.captureStackTrace(this, RecordMissingError)

#db.on 'changes', (changes) ->
#  for change in changes
#    switch change.type
#      when 1 #CREATED
#        db_changes.postMessage({type: 'created', table: change.table, key: change.key, obj: change.obj})
#      when 2 #UPDATED
#        db_changes.postMessage({type: 'updated', table: change.table, key: change.key, obj: change.obj})
#      when 3 #DELETED
#        db_changes.postMessage({type: 'deleted', table: change.table, key: change.key, obj: change.oldObj})

#Dexie.Promise.on 'error', (err) ->
#  Logger.error("Uncaught error: " + err)


